# -*- coding: utf-8 -*-
"""Untitled17.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yS5ZqY8AOVs77mm_OBxaYp8wysRlM0sd
"""

!pip install pyTelegramBotAPI
!pip install SQLAlchemy
!pip install schedule



from sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Enum
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship
import enum
import telebot
from telebot import types
import datetime
import schedule
import time
import threading

# Создание движка базы данных
engine = create_engine('sqlite:///reflection_bot.db')

# Создание базового класса для моделей
Base = declarative_base()

# Определение ролей пользователей
class Role(enum.Enum):
    MANAGER = "manager"
    EMPLOYEE = "employee"

# Модель пользователя
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    telegram_id = Column(Integer, unique=True)
    first_name = Column(String)
    last_name = Column(String)
    role = Column(Enum(Role))
    team_id = Column(Integer, ForeignKey('teams.id'))

# Модель команды
class Team(Base):
    __tablename__ = 'teams'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    users = relationship("User")

# Модель голосования
class Vote(Base):
    __tablename__ = 'votes'
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.telegram_id'))
    energy_level = Column(Integer)  # Уровень энергии от 1 до 10
    date = Column(String)  # Дата голосования

# Создание таблиц в базе данных
Base.metadata.create_all(engine)

# Создание сессии для работы с базой данных
Session = sessionmaker(bind=engine)
session = Session()

import telebot
from telebot import types
import datetime
import threading
import schedule
import time
import logging

#Замените на ваш токен бота
BOT_TOKEN = '8194631795:AAHyeJ2cY2X1ArICPhXCXYRWfMCV_Z3A6v0'
bot = telebot.TeleBot(BOT_TOKEN)

#Клавиатура для выбора роли
def role_keyboard():
  markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
  markup.add(types.KeyboardButton("менеджер"), types.KeyboardButton("работник"))
  return markup

#Клавиатура для голосования
def vote_keyboard():
  markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
  for i in range(1, 11):
    markup.add(types.KeyboardButton(str(i)))
    return markup

#Обработчик команды /start
@bot.message_handler(commands=['start'])
def start(message):
  user = session.query(User).filter_by(telegram_id=message.from_user.id).first()
  if user is None:
    bot.send_message(message.chat.id, "Привет! Для начала работы, пожалуйста, введите вашу роль (manager или employee).", reply_markup=role_keyboard())
  else:
    bot.send_message(message.chat.id, "Вы уже зарегистрированы.")

#Обработчик выбора роли
@bot.message_handler(func=lambda message: message.text in ["manager", "employee"])
def set_role(message):
  user = session.query(User).filter_by(telegram_id=message.from_user.id).first()
  if user is None:
    role = Role(message.text)
    new_user = User(telegram_id=message.from_user.id, role=role)
    session.add(new_user)
    session.commit()
    bot.send_message(message.chat.id, f"Ваша роль установлена как {message.text}. Теперь введите вашу фамилию и имя через пробел.")
  else:
    bot.send_message(message.chat.id, "Вы уже зарегистрированы.")

#Обработчик ввода фамилии и имени
@bot.message_handler(func=lambda message: session.query(User).filter_by(telegram_id=message.from_user.id, first_name=None).first() is not None)
def set_name(message):
  user = session.query(User).filter_by(telegram_id=message.from_user.id).first()
  if user and user.first_name is None:
    try:
      last_name, first_name = message.text.split()
      user.last_name = last_name
      user.first_name = first_name
      session.commit()
      bot.send_message(message.chat.id, f"Ваше имя и фамилия: {first_name} {last_name}. Регистрация завершена.")
      if user.role == Role.EMPLOYEE:
        send_vote_request(user.telegram_id)
    except ValueError:
      bot.send_message(message.chat.id, "Пожалуйста, введите фамилию и имя через пробел.")
    else:
      bot.send_message(message.chat.id, "Вы уже зарегистрированы.")

#Функция отправки запроса на голосование
def send_vote_request(telegram_id):
  bot.send_message(telegram_id, "Пожалуйста, оцените ваш уровень энергии от 1 до 10.", reply_markup=vote_keyboard())

#Обработчик голосования
@bot.message_handler(func=lambda message: message.text.isdigit() and 1 <= int(message.text) <= 10)
def process_vote(message):
  user = session.query(User).filter_by(telegram_id=message.from_user.id).first()
  if user:
    today = datetime.date.today().strftime("%Y-%m-%d")
    vote = Vote(user_id=user.telegram_id, energy_level=int(message.text), date=today)
    session.add(vote)
    session.commit()
    bot.send_message(message.chat.id, "Спасибо, ваш голос учтен!")
  if user.role == Role.MANAGER:
    show_manager_menu(message)

#Функция показа меню менеджера
def show_manager_menu(message):
  markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
  markup.add(types.KeyboardButton("Статистика за день"), types.KeyboardButton("Статистика за неделю"), types.KeyboardButton("Общая статистика"))
  bot.send_message(message.chat.id, "Выберите действие:", reply_markup=markup)

#Клавиатура для управления командами
def team_management_keyboard():
  markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
  markup.add(types.KeyboardButton("Создать команду"), types.KeyboardButton("Добавить пользователя в команду"))
  return markup

#Обработчик команды /manage_teams
@bot.message_handler(commands=['manage_teams'])
def manage_teams(message):
  user = session.query(User).filter_by(telegram_id=message.from_user.id).first()
  if user and user.role == Role.MANAGER:
    bot.send_message(message.chat.id, "Выберите действие:", reply_markup=team_management_keyboard())
  else:
    bot.send_message(message.chat.id, "У вас нет доступа к этой функции.")

#Обработчик запросов статистики от менеджера
@bot.message_handler(func=lambda message: message.text in ["Статистика за день", "Статистика за неделю", "Общая статистика"])
def show_statistics(message):
  user = session.query(User).filter_by(telegram_id=message.from_user.id).first()
  if user and user.role == Role.MANAGER:
    if message.text == "Статистика за день":
      today = datetime.date.today().strftime("%Y-%m-%d")
      votes = session.query(Vote).filter_by(date=today).all()
      show_votes_stats(message, votes, f"Статистика за {today}")
    elif message.text == "Статистика за неделю":
      today = datetime.date.today()
      week_ago = today - datetime.timedelta(days=7)
      votes = session.query(Vote).filter(Vote.date >= week_ago.strftime("%Y-%m-%d")).all()
      show_votes_stats(message, votes, "Статистика за неделю")
    elif message.text == "Общая статистика":
      votes = session.query(Vote).all()
      show_votes_stats(message, votes, "Общая статистика")
    else:
      bot.send_message(message.chat.id, "У вас нет доступа к этой функции.")

#Функция отображения статистики голосования
def show_votes_stats(message, votes, title):
  if votes:
    avg_energy = sum([vote.energy_level for vote in votes]) / len(votes)
    stats = f"{title}:\nСредний уровень энергии: {avg_energy:.2f}\n"
  for vote in votes:
    user = session.query(User).filter_by(telegram_id=vote.user_id).first()
  if user:
    stats += f"{user.first_name} {user.last_name}: {vote.energy_level}\n"
    bot.send_message(message.chat.id, stats)
  else:
    bot.send_message(message.chat.id, "Нет данных для отображения.")

#Функция отправки утреннего уведомления для голосования
def send_morning_notifications():
  users = session.query(User).all()
  for user in users:
    if user.role == Role.EMPLOYEE:
      send_vote_request(user.telegram_id)

#Функция запуска планировщика в отдельном потоке
def run_scheduler():
  send_morning_notifications().do(send_morning_notifications) # Уведомление в 9:00 утра
  while True:
    schedule.run_pending()
    time.sleep(1)

#Запуск планировщика в отдельном потоке
scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)
scheduler_thread.start()

# Запуск бота
bot.polling(none_stop=True)